# Node.js



## 09.06.21

***JavaScript***

> **소개**
>
> - 객체 기반 스크립트 언어
> - 거의 모든 것이 객체
> - 프로토타입 기반 프로그래밍 - 클래스가 없어서 객체를 원형(프로토타입)으로 하여 복제의 과정을 통해 객체의 동작 방식을 사용할 수 있음
> - ES6문법에서 class문법이 추가됐지만, 문법이 추가된 것이지, 자바스크립트가 클래스 기반으로 바뀐 것은 아님

> **스크립트 언어**
>
> - 코드를 한줄씩 번역하고 실행
> - 쉽다
> - 컴파일 언어보다 실행 속도는 느리다

> **문법**
>
> - ECMAScript: 다양한 웹 브라우저에서 자바스크립트가 공통되게 잘 작동하기 위해 만든 표준 규격
> - 2015년에 나온 ES6에서 새로운 기술들 도입
> - 동적 언어이기 때문에 변수 타입을 미리 선언할 필요가 없다
>   - `var` - Function scope => 웬만하면 안씀
>   - `let` / `const` -Block scope

> **객체(Object)** - 배열
>
> - 배열 선언: 모든 형태의 자료형 들어갈 수 있음
> - 배열 요소 순회: `for()`
> - 배열 요소 삽입: `push()` - 맨 뒤에 삽입  / `unshift()` - 맨 앞에 삽입 / 동적으로도 삽입 가능
> - 배열 요소 반환: `array.pop()` - 맨 뒤 값 삭제하고 제거된 요소 반환, `array.shift()` - 맨 첫 값 삭제하고 제거된 요소 반환

> **객체(Object)** - 함수
>
> - 

> **JSON**(JavaScript Object Notation)
>
> - 객체 요소 접근
> - 객체 요소 순회

> **연산자**
>
> - 사칙연산
> - typeof 연산자
> - 비교 연산자

- vscode terminal에서 `node filename` 하면 javascript 실행

> **범위**
>
> - function scope
> - block scope

- back tic(``)으로 변수 포맷팅 가능
  - ex. console.log(`Hello ${World}`)

> **변수**
>
> - 지역 변수
> - 전역 변수



***Node.js***

> **Intro**
>
> - JS기반 서버 플랫폼
> - 구글 V8 엔진 기반 동작
> - 이벤트 기반
> - non-blocking I/O 비동기 방식
> - 싱글 스레드 기반

> **이벤트 기반 시스템**
>
> : 이벤트가 발생할 때 미리 지정해 둔 작업을 수행하는 방식
>
> - 이벤트 리스너에 콜백 함수를 등록
> - 발생할 이벤트가 없거나 발생했던 이벤트를 다 처리하면 다음 이벤트 발생할 때까지 대기
> - 여러 이벤트 동시 발생 시 어떤 순서로 콜백 호출할 지는 이벤트 루프가 판단
> - **이벤트 루프**
>   -  이벤트 발생 시 호출할 콜백 함수들을 관리하고 호출된 콜백 함수의 실행 순서를 결정
>   - 호출 스택이 비어 있을 때만 테스크 큐에 있는 함수를 호출 스택으로 가져옴
>   - 노드가 종료될 때까지 이벤트 처리 작업 반복해서 루프라고 부름
> - **테스크 큐**
>   - 이벤트 발생 후 콜백 함수들이 기다리는 공간
>   - 이벤트 루프가 정한 순서대로 줄 서 있음("콜백 큐"라고도 부름)
> - **백그라운드**
>   - 타이머나 I/O 작업 콜백 또는 이벤트 리스너들이 대기하는 곳
> - 시간이 걸리는 작업을 호출 스택에서 백그라운드로 보내고 백그라운드에서 작업 처리 -> 정해진 시간이 지나고 태스크 큐에서 대기하고 있다가 호출 스택이 비워지면 대기중이던 태스크 큐가 이벤트 루프로 다시 호출 스택으로 
>   - 호출 스택: "코드"
>   - 백그라운드: 시간이 걸리는 작업을 수행하는 공간
>   - 태스크 큐: 백그라운드 작업이 진행되는 동안 대기중인 공간, 호출스택이 비워지면 실행됨

> **동기**
>
> : 요청과 그 결과가 동시에 일어남(요청을 하면 시간이 얼마나 걸리든지 그 자리에서 결과가 주어져야 함)
>
> - 다른 함수 호출 시, 이 함수의 결과를 호출한 쪽에서 처리
> - 호출되는 함수의 작업 완료를 호출한 함수가 신경씀
> - 설계가 직관적이고 간단함

> **비동기**
>
> : 요청과 결과가 동시에 일어나지 않음
>
> - 다른 함수 호출 시, 함수의 결과를 호출한 쪽에서 처리하지 않음
> - 호출되는 함수의 작업 완료를 호출된 함수가 신경 씀
> - 결과가 주어질 때까지 그 시간동안 다른 작업을 할 수 있어서 효율적

> **non-blocking I/O**
>
> - blocking: I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기
>   - I/O작업이 CPU자원을 거의 쓰지 않기 때문에 리소스 낭비가 심함
> - non-blocking: I/O 작업이 완료될때 가지 멈추지 않고 다음 작업 수행
>   - 오래 걸리는 함수를 백그라운드로 보내서 다음 코드가 먼저 실행되게 하고, 그 함수가 다시 태스크 큐를 거쳐 호출 스택으로 올라오기를 기다리는 방식

> **싱글 스레드**
>
> - 프로그램 > 프로세스 > 스레드
> - 프로그램: 정적인 상태.
> - 프로세스: 프로그램이 실행중인 상태. 운영체제로부터 시스템 자원 할당 받는 작업의 단위. 컴퓨터에서 연속적으로 실행되고 잇는 컴퓨터 프로그램 메모리에 올라와 실행되고 잇는 프로그램의 인스턴스. 프로세스 간에는 메모리 등 자원 공유 x
> - 스레드: 프로세스 내에서 실행되는 여러 흐름의 단위(컴퓨터 작업을 처리할 수 있는 일손). 1프로세스 : n스레드. 프로세스가 할당 받은 자원을 이용하는 실행의 단위. 스레드들은 부모 프로세스의 자원 공유 (같은 메모리 접근 가능)

> ***"Node.js는 non-blocking 방식을 사용하는 이벤트 기반의 싱글 스레드, 비동기 방식"***



***실습***

```javascript
const moduleArr = [7, 2, "Hello World", 11, "node", "server", 8, 1];

function sqrt(num) {
  let cnt = 0;
  while (true) {
    if (num % 2 == 0) {
      num = num / 2;
      cnt += 1;
    } else break;
  }
  return cnt;
}

function reverseStr(str) {
  return str.split("").reverse().join("");
}

for (let i = 0; i < moduleArr.length; i++) {
  if (typeof moduleArr[i] === "string") {
    console.log(reverseStr(moduleArr[i]));
  } else {
    if (moduleArr[i] % 2 == 0) {
      console.log(sqrt(moduleArr[i]));
    } else {
      console.log("홀수입니다");
    }
  }
}
```





### 통신

***HTTP*** (Hyper Text Transfer Protocol)

***npx*** vs ***npm***

- npx: Node Package Manager
  - Node.js의 오픈소스 모듈을 모아둔 저장소
  - 세계에서 가장 큰 오픈소스 라이브러리 생태계
  - 모듈의 버전관리가 쉽게 가능
  - npm에 업로드 된 노드 모듈을 "패키지"라고 부름
- package.json: 설치한 패키지 버전을 관리하는 파일 => 패키지 리스트 => `npm install` 터미널에 명령하면 모든 패키지 다운
  - 다양한 패키지들이 서로 의존하고 있기 때문에 다량의 파일들 설치됨
  - 의존성 모듈을 쉽게 관리해줌
- npm: 단순 패키지 구성
- `npm run start`: 서버 작동 시작 명령어
- 화면에 나타나는 것을 담당하는 파일은 ejs파일 (in views folder)
  - routes folder에 index.js파일에서 데이터 가져옴



### > ***Express***

- 코드 변경하고 적용하려면 서버 중지시키고 다시 가동

  - 패키지 중 자동으로 적용시켜주는 패키지 존재 => ***nodemon***: 서버를 재가동하지 않고도 변경사항 적용시켜줌
  - `-D`: 개발환경에서만 사용 => `npm install -D nodemon` => `-g`로 install
  - `nodemon ./bin/www`
  - package.json 파일에 "scripts"에 사용자 설정의 명령어 추가 가능 => "dev" - `npm run dev`
    - `npm run` 다음에 명령어를 입력: "scripts" object에 명령어에 해당하는 명령 수행

  

  **route**

  - json 형태로 전달
  - "root router": http://localhost:3000
  - postman(client: 요청을 보내는 주체)으로 request + server(: 요청을 받는 주체)가 response => "통신"
  - url에 정보를 입력하여 통신 => "query"형식 (get method): 문자열로 정보를 요청
    - query 날리고 - 콜백함수로 정보 받아서 변수에 저장 - 요청한 변수, 저장된 변수를 object형식으로 응답 => get method